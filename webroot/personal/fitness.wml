# $Id$
#include <template.wml> topic="about"

# Some Perl functions to support the statistics in this page:
<:
use strict;
use warnings;
use File::Path qw( make_path );
use Storable;
use WebService::GarminConnect;
use Config::Simple;
use POSIX qw(mktime strftime);
use Data::Dumper;

# SUBROUTINE:  commify()
# DESCRIPTION: Add commas to a number to separate the thousands.
#              From Perl Cookbook, 2.17, p. 64
sub commify {
  # commify a number. Perl Cookbook, 2.17, p. 64
  my $text = reverse $_[0];
  $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
  return scalar reverse $text;
}

# SUBROUTINE:  date($seconds_since_epoch)
# DESCRIPTION: Return a nicely-formatted date string (no time).
sub pretty_print_date {
  my $seconds_since_epoch = $_[0];
  return strftime("%b %e, %Y", localtime($seconds_since_epoch));
}

# SUBROUTINE: pretty_print_speed($meters_per_second)
# DESCRIPTION: Return a nicely formatted "MM:SS min/mi"
sub pretty_print_speed {
  my $meters_per_second = $_[0];
  my $minutes_per_mile = 26.8224 / $meters_per_second;

  my $minutes = int($minutes_per_mile);
  my $seconds_fractional = $minutes_per_mile - $minutes;
  my $seconds = $seconds_fractional * 60;
  return sprintf("%d:%04.1f min/mi", $minutes, $seconds);
}

# SUBROUTINE:  activities()
# DESCRIPTION: Returns a reference to a list of all activities. If cached data
#              is available and recent enough, that is what is returned.
#              Otherwise, fetches the data from Garmin Connect.
sub activities {
  my $configfile = $ENV{HOME} . '/.websiterc';
  my $cachedir = $ENV{HOME} . '/.cache/website';
  my $cachefile = $cachedir . '/activities.cache';

  # Is the cache available and recent?
  my $recent_enough = mktime(localtime(time - 60*60*23)); # 23 hours ago
  if( -r $cachefile && (stat(_))[9] >= $recent_enough ) {
    return retrieve($cachefile);
  }

  # Call Garmin Connect to get the data.
  # Get the user's Garmin Connect username/password.
  my $config = new Config::Simple($configfile);
  my $connect = WebService::GarminConnect->new(
    username => $config->param('garmin_connect.username'),
    password => $config->param('garmin_connect.password')
  );
  my @activities = $connect->activities();

  # Cache the activities before returning them.
  if( @activities ) {
    if( ! -e $cachedir ) {
      make_path($cachedir);
    }
    store(\@activities, $cachefile);
  }

  return \@activities;
}

# SUBROUTINE:  milesInYear($year, $activity_name)
# DESCRIPTION: Returns the number of miles in $year for a given activity.
sub milesInYear {
  my ($year, $activity_name) = @_;
  my $activities = activities();
  my $total_miles = 0;
  my $types = {
    running => 1,
    cycling => 2,
    hiking  => 3,
  };
  if( !defined($types->{lc($activity_name)}) ) {
    die "unknown activity type: $activity_name";
  }
  foreach my $a ( @{$activities} ) {
    # Count only activities of the requested type
    my $type = $a->{activity}->{activityType};
    next unless ($type->{typeId} eq $types->{lc($activity_name)} or
                 $type->{parentTypeId} eq $types->{lc($activity_name)});

    # Count only activities from the requested year
    my $activity_year = 1900 +
     (localtime($a->{activity}->{beginTimestamp}/1000))[5];
    next unless $activity_year == $year;

    $total_miles += $a->{activity}->{distance} / 1609.344; # meters to miles
  }

  # Return a number with a reasonable precision
  return sprintf("%0.2f", $total_miles);
}

# SUBROUTINE:  fastestRuns( minMiles => $min,
#                           maxMiles => $max,
#                           numResults => $num )
# DESCRIPTION: Returns the $num fastest runs that are at least $min miles
#              but not more than $max miles in length. You can specify
#              just a minimum bound or just a maximum, or both. The results
#              are returned as a list reference of activities.
sub fastestRuns {
  my %opts = @_;
  if( !defined $opts{numResults} ) {
    die "numResults is required";
  }
  if( !defined $opts{minMiles} && !defined $opts{maxMiles} ) {
    die "at least one of minMiles or maxMiles is required";
  }

  my $activities = activities();
  # Create a list of just runs which match the min/max, which we will sort
  # later.
  my @matchingRuns;
  foreach my $a ( @{$activities} ) {
    # Count only running activities
    next unless ($a->{activity}->{activityType}->{typeId} eq 1 or
                 $a->{activity}->{activityType}->{parentTypeId} eq 1);

    # Enforce the minimum distance
    if( defined $opts{minMiles} ) {
      next unless $a->{activity}->{distance} / 1609.344 >= $opts{minMiles};
    }

    # Enforce the maximum distance
    if( defined $opts{maxMiles} ) {
      next unless $a->{activity}->{distance} / 1609.344 <= $opts{maxMiles};
    }

    push @matchingRuns, $a;
  }

  # Sort the matching run list so that the fastest runs are first.
  @matchingRuns = sort {
    $b->{activity}->{averageSpeed} <=>
      $a->{activity}->{averageSpeed}
  } @matchingRuns;

  # Slice off however many the user requested from the front of the list.
  my @fastestRuns = @matchingRuns[0 .. $opts{numResults}-1];

  return \@fastestRuns;
}

# SUBROUTINE:  milesInCurrentShoes()
# DESCRIPTION: Returns the number of miles run since the last 'new shoes' run,
#              ignoring any 'old shoes' runs.
sub milesInCurrentShoes {
  my $activities = activities();
  my $total_miles = 0;

  # Sort the activities from most recent to least recent.
  foreach my $a ( sort {
                    $b->{activity}->{beginTimestamp} <=>
                    $a->{activity}->{beginTimestamp} }
                  @{$activities} ) {
    # Count only running activities
    next unless ($a->{activity}->{activityType}->{typeId} eq 1 or
                 $a->{activity}->{activityType}->{parentTypeId} eq 1);

    # Don't count any runs in old shoes
    next if (defined $a->{activity}->{description} &&
             $a->{activity}->{description}
               =~ /\bold shoes\b/);

    $total_miles += $a->{activity}->{distance} / 1609.344;

    last if (defined $a->{activity}->{description} &&
             $a->{activity}->{description}
               =~ /\bnew shoes\b/);
  }

  # Return a number with a reasonable precision
  return sprintf("%0.2f", $total_miles);
}
:>

<title "Fitness">

<heading>Fitness</heading>

<h3>Background</h3>

<p>I like to run for exercise, and for years I have been using a GPS watch
to keep track of my pace and distance. This is much more accurate
than using a pedometer, which is just counting your steps and taking a guess
as to how far you've run. Also, I can upload my data to Garmin Connect so
that I can review the history and get interesting statistics like the
ones below. Well, they're interesting to me, at least.</p>

<h3>Miles run and biked per year</h3>

<p>It wasn't until 2010 that I started entering
all my treadmill runs manually. There are a few months each summer when it's
too hot for a long run outside. So the years prior to 2010 are counting
only outdoor runs.</p>

<table class="chart">
<tr>
  <th>Year</th>
  <th>Miles Run</th>
  <th>Miles Biked</th>
  <th>Miles Hiked</th>
</tr>
<: foreach my $year ( 2008 .. ((localtime(time))[5]+1900) ) { _:>
<tr>
  <td><:= $year :></td>
  <td><:= commify(milesInYear($year, 'Running')) :></td>
  <td><:= commify(milesInYear($year, 'Cycling')) :></td>
  <td><:= commify(milesInYear($year, 'Hiking')) :></td>
</tr>
<: } :>
</table>

<p>I also use this data to track how much I've run since I last changed shoes.
Since I run on smooth roads and treadmills, you can't tell from looking at a
shoe's tread how worn it is. It will look like it has plenty of tread long
after I have compressed all of the cushion out of the padding inside the
shoe.</p>

<p>Miles run in current shoes: <:= milesInCurrentShoes() :></p>

<p>I try to change shoes about every 300 miles or so.</p>

<h3>Fastest long runs</h3>

<p>I run a long run once a week, usually on the weekend. Lately these have
been about 12-13 miles. This is a list of the fastest runs over 10 miles.</p>

<table class="chart">
<tr>
  <th>Title</th>
  <th>Date</th>
  <th>Speed</th>
  <th>Distance</th>
</tr>
<: foreach my $run ( @{fastestRuns(minMiles => 10, numResults => 5)} ) { _:>
<tr>
  <td><a href="http://connect.garmin.com/modern/activity/<:= $run->{activity}->{activityId} :>"><:= $run->{activity}->{activityName} || 'Untitled' :></a></td>
  <td><:= pretty_print_date($run->{activity}->{beginTimestamp} / 1000) :></td>
  <td><:= pretty_print_speed($run->{activity}->{averageSpeed}) :></td>
  <td><:= sprintf("%.02f mi", $run->{activity}->{distance} / 1609.344) :></td>
</tr>
<: } :>
</table>

<h3>Fastest short runs</h3>

<p>Not to be left out, here are the fastest short runs. These are runs three
to six miles in length.</p>

<table class="chart">
<tr>
  <th>Title</th>
  <th>Date</th>
  <th>Speed</th>
  <th>Distance</th>
</tr>
<: foreach my $run ( @{fastestRuns(minMiles => 3, maxMiles => 6, numResults => 5)} ) { _:>
<tr>
  <td><a href="http://connect.garmin.com/modern/activity/<:= $run->{activity}->{activityId} :>"><:= $run->{activity}->{activityName} || 'Untitled' :></a></td>
  <td><:= pretty_print_date($run->{activity}->{beginTimestamp} / 1000) :></td>
  <td><:= pretty_print_speed($run->{activity}->{averageSpeed}) :></td>
  <td><:= sprintf("%.02f mi", $run->{activity}->{distance} / 1609.344) :></td>
</tr>
<: } :>
</table>

